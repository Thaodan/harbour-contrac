// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: contrac.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_contrac_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_contrac_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3010000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3010001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_contrac_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_contrac_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[5]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
namespace Diagnosis {
class SignatureInfo;
class SignatureInfoDefaultTypeInternal;
extern SignatureInfoDefaultTypeInternal _SignatureInfo_default_instance_;
class TEKSignature;
class TEKSignatureDefaultTypeInternal;
extern TEKSignatureDefaultTypeInternal _TEKSignature_default_instance_;
class TEKSignatureList;
class TEKSignatureListDefaultTypeInternal;
extern TEKSignatureListDefaultTypeInternal _TEKSignatureList_default_instance_;
class TemporaryExposureKey;
class TemporaryExposureKeyDefaultTypeInternal;
extern TemporaryExposureKeyDefaultTypeInternal _TemporaryExposureKey_default_instance_;
class TemporaryExposureKeyExport;
class TemporaryExposureKeyExportDefaultTypeInternal;
extern TemporaryExposureKeyExportDefaultTypeInternal _TemporaryExposureKeyExport_default_instance_;
}  // namespace Diagnosis
PROTOBUF_NAMESPACE_OPEN
template<> ::Diagnosis::SignatureInfo* Arena::CreateMaybeMessage<::Diagnosis::SignatureInfo>(Arena*);
template<> ::Diagnosis::TEKSignature* Arena::CreateMaybeMessage<::Diagnosis::TEKSignature>(Arena*);
template<> ::Diagnosis::TEKSignatureList* Arena::CreateMaybeMessage<::Diagnosis::TEKSignatureList>(Arena*);
template<> ::Diagnosis::TemporaryExposureKey* Arena::CreateMaybeMessage<::Diagnosis::TemporaryExposureKey>(Arena*);
template<> ::Diagnosis::TemporaryExposureKeyExport* Arena::CreateMaybeMessage<::Diagnosis::TemporaryExposureKeyExport>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace Diagnosis {

// ===================================================================

class TemporaryExposureKeyExport :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Diagnosis.TemporaryExposureKeyExport) */ {
 public:
  TemporaryExposureKeyExport();
  virtual ~TemporaryExposureKeyExport();

  TemporaryExposureKeyExport(const TemporaryExposureKeyExport& from);
  TemporaryExposureKeyExport(TemporaryExposureKeyExport&& from) noexcept
    : TemporaryExposureKeyExport() {
    *this = ::std::move(from);
  }

  inline TemporaryExposureKeyExport& operator=(const TemporaryExposureKeyExport& from) {
    CopyFrom(from);
    return *this;
  }
  inline TemporaryExposureKeyExport& operator=(TemporaryExposureKeyExport&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const TemporaryExposureKeyExport& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TemporaryExposureKeyExport* internal_default_instance() {
    return reinterpret_cast<const TemporaryExposureKeyExport*>(
               &_TemporaryExposureKeyExport_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(TemporaryExposureKeyExport& a, TemporaryExposureKeyExport& b) {
    a.Swap(&b);
  }
  inline void Swap(TemporaryExposureKeyExport* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TemporaryExposureKeyExport* New() const final {
    return CreateMaybeMessage<TemporaryExposureKeyExport>(nullptr);
  }

  TemporaryExposureKeyExport* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TemporaryExposureKeyExport>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const TemporaryExposureKeyExport& from);
  void MergeFrom(const TemporaryExposureKeyExport& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TemporaryExposureKeyExport* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Diagnosis.TemporaryExposureKeyExport";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSignatureInfosFieldNumber = 6,
    kKeysFieldNumber = 7,
    kRegionFieldNumber = 3,
    kStartTimestampFieldNumber = 1,
    kEndTimestampFieldNumber = 2,
    kBatchNumFieldNumber = 4,
    kBatchSizeFieldNumber = 5,
  };
  // repeated .Diagnosis.SignatureInfo signature_infos = 6;
  int signature_infos_size() const;
  private:
  int _internal_signature_infos_size() const;
  public:
  void clear_signature_infos();
  ::Diagnosis::SignatureInfo* mutable_signature_infos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Diagnosis::SignatureInfo >*
      mutable_signature_infos();
  private:
  const ::Diagnosis::SignatureInfo& _internal_signature_infos(int index) const;
  ::Diagnosis::SignatureInfo* _internal_add_signature_infos();
  public:
  const ::Diagnosis::SignatureInfo& signature_infos(int index) const;
  ::Diagnosis::SignatureInfo* add_signature_infos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Diagnosis::SignatureInfo >&
      signature_infos() const;

  // repeated .Diagnosis.TemporaryExposureKey keys = 7;
  int keys_size() const;
  private:
  int _internal_keys_size() const;
  public:
  void clear_keys();
  ::Diagnosis::TemporaryExposureKey* mutable_keys(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Diagnosis::TemporaryExposureKey >*
      mutable_keys();
  private:
  const ::Diagnosis::TemporaryExposureKey& _internal_keys(int index) const;
  ::Diagnosis::TemporaryExposureKey* _internal_add_keys();
  public:
  const ::Diagnosis::TemporaryExposureKey& keys(int index) const;
  ::Diagnosis::TemporaryExposureKey* add_keys();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Diagnosis::TemporaryExposureKey >&
      keys() const;

  // optional string region = 3;
  bool has_region() const;
  private:
  bool _internal_has_region() const;
  public:
  void clear_region();
  const std::string& region() const;
  void set_region(const std::string& value);
  void set_region(std::string&& value);
  void set_region(const char* value);
  void set_region(const char* value, size_t size);
  std::string* mutable_region();
  std::string* release_region();
  void set_allocated_region(std::string* region);
  private:
  const std::string& _internal_region() const;
  void _internal_set_region(const std::string& value);
  std::string* _internal_mutable_region();
  public:

  // optional fixed64 start_timestamp = 1;
  bool has_start_timestamp() const;
  private:
  bool _internal_has_start_timestamp() const;
  public:
  void clear_start_timestamp();
  ::PROTOBUF_NAMESPACE_ID::uint64 start_timestamp() const;
  void set_start_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_start_timestamp() const;
  void _internal_set_start_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional fixed64 end_timestamp = 2;
  bool has_end_timestamp() const;
  private:
  bool _internal_has_end_timestamp() const;
  public:
  void clear_end_timestamp();
  ::PROTOBUF_NAMESPACE_ID::uint64 end_timestamp() const;
  void set_end_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_end_timestamp() const;
  void _internal_set_end_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional int32 batch_num = 4;
  bool has_batch_num() const;
  private:
  bool _internal_has_batch_num() const;
  public:
  void clear_batch_num();
  ::PROTOBUF_NAMESPACE_ID::int32 batch_num() const;
  void set_batch_num(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_batch_num() const;
  void _internal_set_batch_num(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 batch_size = 5;
  bool has_batch_size() const;
  private:
  bool _internal_has_batch_size() const;
  public:
  void clear_batch_size();
  ::PROTOBUF_NAMESPACE_ID::int32 batch_size() const;
  void set_batch_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_batch_size() const;
  void _internal_set_batch_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:Diagnosis.TemporaryExposureKeyExport)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Diagnosis::SignatureInfo > signature_infos_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Diagnosis::TemporaryExposureKey > keys_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr region_;
  ::PROTOBUF_NAMESPACE_ID::uint64 start_timestamp_;
  ::PROTOBUF_NAMESPACE_ID::uint64 end_timestamp_;
  ::PROTOBUF_NAMESPACE_ID::int32 batch_num_;
  ::PROTOBUF_NAMESPACE_ID::int32 batch_size_;
  friend struct ::TableStruct_contrac_2eproto;
};
// -------------------------------------------------------------------

class SignatureInfo :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Diagnosis.SignatureInfo) */ {
 public:
  SignatureInfo();
  virtual ~SignatureInfo();

  SignatureInfo(const SignatureInfo& from);
  SignatureInfo(SignatureInfo&& from) noexcept
    : SignatureInfo() {
    *this = ::std::move(from);
  }

  inline SignatureInfo& operator=(const SignatureInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignatureInfo& operator=(SignatureInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const SignatureInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SignatureInfo* internal_default_instance() {
    return reinterpret_cast<const SignatureInfo*>(
               &_SignatureInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SignatureInfo& a, SignatureInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(SignatureInfo* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SignatureInfo* New() const final {
    return CreateMaybeMessage<SignatureInfo>(nullptr);
  }

  SignatureInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SignatureInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const SignatureInfo& from);
  void MergeFrom(const SignatureInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SignatureInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Diagnosis.SignatureInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAppBundleIdFieldNumber = 1,
    kAndroidPackageFieldNumber = 2,
    kVerificationKeyVersionFieldNumber = 3,
    kVerificationKeyIdFieldNumber = 4,
    kSignatureAlgorithmFieldNumber = 5,
  };
  // optional string app_bundle_id = 1;
  bool has_app_bundle_id() const;
  private:
  bool _internal_has_app_bundle_id() const;
  public:
  void clear_app_bundle_id();
  const std::string& app_bundle_id() const;
  void set_app_bundle_id(const std::string& value);
  void set_app_bundle_id(std::string&& value);
  void set_app_bundle_id(const char* value);
  void set_app_bundle_id(const char* value, size_t size);
  std::string* mutable_app_bundle_id();
  std::string* release_app_bundle_id();
  void set_allocated_app_bundle_id(std::string* app_bundle_id);
  private:
  const std::string& _internal_app_bundle_id() const;
  void _internal_set_app_bundle_id(const std::string& value);
  std::string* _internal_mutable_app_bundle_id();
  public:

  // optional string android_package = 2;
  bool has_android_package() const;
  private:
  bool _internal_has_android_package() const;
  public:
  void clear_android_package();
  const std::string& android_package() const;
  void set_android_package(const std::string& value);
  void set_android_package(std::string&& value);
  void set_android_package(const char* value);
  void set_android_package(const char* value, size_t size);
  std::string* mutable_android_package();
  std::string* release_android_package();
  void set_allocated_android_package(std::string* android_package);
  private:
  const std::string& _internal_android_package() const;
  void _internal_set_android_package(const std::string& value);
  std::string* _internal_mutable_android_package();
  public:

  // optional string verification_key_version = 3;
  bool has_verification_key_version() const;
  private:
  bool _internal_has_verification_key_version() const;
  public:
  void clear_verification_key_version();
  const std::string& verification_key_version() const;
  void set_verification_key_version(const std::string& value);
  void set_verification_key_version(std::string&& value);
  void set_verification_key_version(const char* value);
  void set_verification_key_version(const char* value, size_t size);
  std::string* mutable_verification_key_version();
  std::string* release_verification_key_version();
  void set_allocated_verification_key_version(std::string* verification_key_version);
  private:
  const std::string& _internal_verification_key_version() const;
  void _internal_set_verification_key_version(const std::string& value);
  std::string* _internal_mutable_verification_key_version();
  public:

  // optional string verification_key_id = 4;
  bool has_verification_key_id() const;
  private:
  bool _internal_has_verification_key_id() const;
  public:
  void clear_verification_key_id();
  const std::string& verification_key_id() const;
  void set_verification_key_id(const std::string& value);
  void set_verification_key_id(std::string&& value);
  void set_verification_key_id(const char* value);
  void set_verification_key_id(const char* value, size_t size);
  std::string* mutable_verification_key_id();
  std::string* release_verification_key_id();
  void set_allocated_verification_key_id(std::string* verification_key_id);
  private:
  const std::string& _internal_verification_key_id() const;
  void _internal_set_verification_key_id(const std::string& value);
  std::string* _internal_mutable_verification_key_id();
  public:

  // optional string signature_algorithm = 5;
  bool has_signature_algorithm() const;
  private:
  bool _internal_has_signature_algorithm() const;
  public:
  void clear_signature_algorithm();
  const std::string& signature_algorithm() const;
  void set_signature_algorithm(const std::string& value);
  void set_signature_algorithm(std::string&& value);
  void set_signature_algorithm(const char* value);
  void set_signature_algorithm(const char* value, size_t size);
  std::string* mutable_signature_algorithm();
  std::string* release_signature_algorithm();
  void set_allocated_signature_algorithm(std::string* signature_algorithm);
  private:
  const std::string& _internal_signature_algorithm() const;
  void _internal_set_signature_algorithm(const std::string& value);
  std::string* _internal_mutable_signature_algorithm();
  public:

  // @@protoc_insertion_point(class_scope:Diagnosis.SignatureInfo)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr app_bundle_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr android_package_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr verification_key_version_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr verification_key_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signature_algorithm_;
  friend struct ::TableStruct_contrac_2eproto;
};
// -------------------------------------------------------------------

class TemporaryExposureKey :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Diagnosis.TemporaryExposureKey) */ {
 public:
  TemporaryExposureKey();
  virtual ~TemporaryExposureKey();

  TemporaryExposureKey(const TemporaryExposureKey& from);
  TemporaryExposureKey(TemporaryExposureKey&& from) noexcept
    : TemporaryExposureKey() {
    *this = ::std::move(from);
  }

  inline TemporaryExposureKey& operator=(const TemporaryExposureKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline TemporaryExposureKey& operator=(TemporaryExposureKey&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const TemporaryExposureKey& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TemporaryExposureKey* internal_default_instance() {
    return reinterpret_cast<const TemporaryExposureKey*>(
               &_TemporaryExposureKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(TemporaryExposureKey& a, TemporaryExposureKey& b) {
    a.Swap(&b);
  }
  inline void Swap(TemporaryExposureKey* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TemporaryExposureKey* New() const final {
    return CreateMaybeMessage<TemporaryExposureKey>(nullptr);
  }

  TemporaryExposureKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TemporaryExposureKey>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const TemporaryExposureKey& from);
  void MergeFrom(const TemporaryExposureKey& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TemporaryExposureKey* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Diagnosis.TemporaryExposureKey";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyDataFieldNumber = 1,
    kTransmissionRiskLevelFieldNumber = 2,
    kRollingStartIntervalNumberFieldNumber = 3,
    kRollingPeriodFieldNumber = 4,
  };
  // optional bytes key_data = 1;
  bool has_key_data() const;
  private:
  bool _internal_has_key_data() const;
  public:
  void clear_key_data();
  const std::string& key_data() const;
  void set_key_data(const std::string& value);
  void set_key_data(std::string&& value);
  void set_key_data(const char* value);
  void set_key_data(const void* value, size_t size);
  std::string* mutable_key_data();
  std::string* release_key_data();
  void set_allocated_key_data(std::string* key_data);
  private:
  const std::string& _internal_key_data() const;
  void _internal_set_key_data(const std::string& value);
  std::string* _internal_mutable_key_data();
  public:

  // optional int32 transmission_risk_level = 2;
  bool has_transmission_risk_level() const;
  private:
  bool _internal_has_transmission_risk_level() const;
  public:
  void clear_transmission_risk_level();
  ::PROTOBUF_NAMESPACE_ID::int32 transmission_risk_level() const;
  void set_transmission_risk_level(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_transmission_risk_level() const;
  void _internal_set_transmission_risk_level(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 rolling_start_interval_number = 3;
  bool has_rolling_start_interval_number() const;
  private:
  bool _internal_has_rolling_start_interval_number() const;
  public:
  void clear_rolling_start_interval_number();
  ::PROTOBUF_NAMESPACE_ID::int32 rolling_start_interval_number() const;
  void set_rolling_start_interval_number(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_rolling_start_interval_number() const;
  void _internal_set_rolling_start_interval_number(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 rolling_period = 4 [default = 144];
  bool has_rolling_period() const;
  private:
  bool _internal_has_rolling_period() const;
  public:
  void clear_rolling_period();
  ::PROTOBUF_NAMESPACE_ID::int32 rolling_period() const;
  void set_rolling_period(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_rolling_period() const;
  void _internal_set_rolling_period(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:Diagnosis.TemporaryExposureKey)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_data_;
  ::PROTOBUF_NAMESPACE_ID::int32 transmission_risk_level_;
  ::PROTOBUF_NAMESPACE_ID::int32 rolling_start_interval_number_;
  ::PROTOBUF_NAMESPACE_ID::int32 rolling_period_;
  friend struct ::TableStruct_contrac_2eproto;
};
// -------------------------------------------------------------------

class TEKSignatureList :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Diagnosis.TEKSignatureList) */ {
 public:
  TEKSignatureList();
  virtual ~TEKSignatureList();

  TEKSignatureList(const TEKSignatureList& from);
  TEKSignatureList(TEKSignatureList&& from) noexcept
    : TEKSignatureList() {
    *this = ::std::move(from);
  }

  inline TEKSignatureList& operator=(const TEKSignatureList& from) {
    CopyFrom(from);
    return *this;
  }
  inline TEKSignatureList& operator=(TEKSignatureList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const TEKSignatureList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TEKSignatureList* internal_default_instance() {
    return reinterpret_cast<const TEKSignatureList*>(
               &_TEKSignatureList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(TEKSignatureList& a, TEKSignatureList& b) {
    a.Swap(&b);
  }
  inline void Swap(TEKSignatureList* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TEKSignatureList* New() const final {
    return CreateMaybeMessage<TEKSignatureList>(nullptr);
  }

  TEKSignatureList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TEKSignatureList>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const TEKSignatureList& from);
  void MergeFrom(const TEKSignatureList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TEKSignatureList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Diagnosis.TEKSignatureList";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSignaturesFieldNumber = 1,
  };
  // repeated .Diagnosis.TEKSignature signatures = 1;
  int signatures_size() const;
  private:
  int _internal_signatures_size() const;
  public:
  void clear_signatures();
  ::Diagnosis::TEKSignature* mutable_signatures(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Diagnosis::TEKSignature >*
      mutable_signatures();
  private:
  const ::Diagnosis::TEKSignature& _internal_signatures(int index) const;
  ::Diagnosis::TEKSignature* _internal_add_signatures();
  public:
  const ::Diagnosis::TEKSignature& signatures(int index) const;
  ::Diagnosis::TEKSignature* add_signatures();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Diagnosis::TEKSignature >&
      signatures() const;

  // @@protoc_insertion_point(class_scope:Diagnosis.TEKSignatureList)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Diagnosis::TEKSignature > signatures_;
  friend struct ::TableStruct_contrac_2eproto;
};
// -------------------------------------------------------------------

class TEKSignature :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Diagnosis.TEKSignature) */ {
 public:
  TEKSignature();
  virtual ~TEKSignature();

  TEKSignature(const TEKSignature& from);
  TEKSignature(TEKSignature&& from) noexcept
    : TEKSignature() {
    *this = ::std::move(from);
  }

  inline TEKSignature& operator=(const TEKSignature& from) {
    CopyFrom(from);
    return *this;
  }
  inline TEKSignature& operator=(TEKSignature&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const TEKSignature& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TEKSignature* internal_default_instance() {
    return reinterpret_cast<const TEKSignature*>(
               &_TEKSignature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(TEKSignature& a, TEKSignature& b) {
    a.Swap(&b);
  }
  inline void Swap(TEKSignature* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TEKSignature* New() const final {
    return CreateMaybeMessage<TEKSignature>(nullptr);
  }

  TEKSignature* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TEKSignature>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const TEKSignature& from);
  void MergeFrom(const TEKSignature& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TEKSignature* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Diagnosis.TEKSignature";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSignatureFieldNumber = 4,
    kSignatureInfoFieldNumber = 1,
    kBatchNumFieldNumber = 2,
    kBatchSizeFieldNumber = 3,
  };
  // optional bytes signature = 4;
  bool has_signature() const;
  private:
  bool _internal_has_signature() const;
  public:
  void clear_signature();
  const std::string& signature() const;
  void set_signature(const std::string& value);
  void set_signature(std::string&& value);
  void set_signature(const char* value);
  void set_signature(const void* value, size_t size);
  std::string* mutable_signature();
  std::string* release_signature();
  void set_allocated_signature(std::string* signature);
  private:
  const std::string& _internal_signature() const;
  void _internal_set_signature(const std::string& value);
  std::string* _internal_mutable_signature();
  public:

  // optional .Diagnosis.SignatureInfo signature_info = 1;
  bool has_signature_info() const;
  private:
  bool _internal_has_signature_info() const;
  public:
  void clear_signature_info();
  const ::Diagnosis::SignatureInfo& signature_info() const;
  ::Diagnosis::SignatureInfo* release_signature_info();
  ::Diagnosis::SignatureInfo* mutable_signature_info();
  void set_allocated_signature_info(::Diagnosis::SignatureInfo* signature_info);
  private:
  const ::Diagnosis::SignatureInfo& _internal_signature_info() const;
  ::Diagnosis::SignatureInfo* _internal_mutable_signature_info();
  public:

  // optional int32 batch_num = 2;
  bool has_batch_num() const;
  private:
  bool _internal_has_batch_num() const;
  public:
  void clear_batch_num();
  ::PROTOBUF_NAMESPACE_ID::int32 batch_num() const;
  void set_batch_num(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_batch_num() const;
  void _internal_set_batch_num(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 batch_size = 3;
  bool has_batch_size() const;
  private:
  bool _internal_has_batch_size() const;
  public:
  void clear_batch_size();
  ::PROTOBUF_NAMESPACE_ID::int32 batch_size() const;
  void set_batch_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_batch_size() const;
  void _internal_set_batch_size(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:Diagnosis.TEKSignature)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signature_;
  ::Diagnosis::SignatureInfo* signature_info_;
  ::PROTOBUF_NAMESPACE_ID::int32 batch_num_;
  ::PROTOBUF_NAMESPACE_ID::int32 batch_size_;
  friend struct ::TableStruct_contrac_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// TemporaryExposureKeyExport

// optional fixed64 start_timestamp = 1;
inline bool TemporaryExposureKeyExport::_internal_has_start_timestamp() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TemporaryExposureKeyExport::has_start_timestamp() const {
  return _internal_has_start_timestamp();
}
inline void TemporaryExposureKeyExport::clear_start_timestamp() {
  start_timestamp_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 TemporaryExposureKeyExport::_internal_start_timestamp() const {
  return start_timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 TemporaryExposureKeyExport::start_timestamp() const {
  // @@protoc_insertion_point(field_get:Diagnosis.TemporaryExposureKeyExport.start_timestamp)
  return _internal_start_timestamp();
}
inline void TemporaryExposureKeyExport::_internal_set_start_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  start_timestamp_ = value;
}
inline void TemporaryExposureKeyExport::set_start_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_start_timestamp(value);
  // @@protoc_insertion_point(field_set:Diagnosis.TemporaryExposureKeyExport.start_timestamp)
}

// optional fixed64 end_timestamp = 2;
inline bool TemporaryExposureKeyExport::_internal_has_end_timestamp() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TemporaryExposureKeyExport::has_end_timestamp() const {
  return _internal_has_end_timestamp();
}
inline void TemporaryExposureKeyExport::clear_end_timestamp() {
  end_timestamp_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 TemporaryExposureKeyExport::_internal_end_timestamp() const {
  return end_timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 TemporaryExposureKeyExport::end_timestamp() const {
  // @@protoc_insertion_point(field_get:Diagnosis.TemporaryExposureKeyExport.end_timestamp)
  return _internal_end_timestamp();
}
inline void TemporaryExposureKeyExport::_internal_set_end_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  end_timestamp_ = value;
}
inline void TemporaryExposureKeyExport::set_end_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_end_timestamp(value);
  // @@protoc_insertion_point(field_set:Diagnosis.TemporaryExposureKeyExport.end_timestamp)
}

// optional string region = 3;
inline bool TemporaryExposureKeyExport::_internal_has_region() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TemporaryExposureKeyExport::has_region() const {
  return _internal_has_region();
}
inline void TemporaryExposureKeyExport::clear_region() {
  region_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TemporaryExposureKeyExport::region() const {
  // @@protoc_insertion_point(field_get:Diagnosis.TemporaryExposureKeyExport.region)
  return _internal_region();
}
inline void TemporaryExposureKeyExport::set_region(const std::string& value) {
  _internal_set_region(value);
  // @@protoc_insertion_point(field_set:Diagnosis.TemporaryExposureKeyExport.region)
}
inline std::string* TemporaryExposureKeyExport::mutable_region() {
  // @@protoc_insertion_point(field_mutable:Diagnosis.TemporaryExposureKeyExport.region)
  return _internal_mutable_region();
}
inline const std::string& TemporaryExposureKeyExport::_internal_region() const {
  return region_.GetNoArena();
}
inline void TemporaryExposureKeyExport::_internal_set_region(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  region_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void TemporaryExposureKeyExport::set_region(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  region_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Diagnosis.TemporaryExposureKeyExport.region)
}
inline void TemporaryExposureKeyExport::set_region(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  region_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Diagnosis.TemporaryExposureKeyExport.region)
}
inline void TemporaryExposureKeyExport::set_region(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  region_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Diagnosis.TemporaryExposureKeyExport.region)
}
inline std::string* TemporaryExposureKeyExport::_internal_mutable_region() {
  _has_bits_[0] |= 0x00000001u;
  return region_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* TemporaryExposureKeyExport::release_region() {
  // @@protoc_insertion_point(field_release:Diagnosis.TemporaryExposureKeyExport.region)
  if (!has_region()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return region_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void TemporaryExposureKeyExport::set_allocated_region(std::string* region) {
  if (region != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  region_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), region);
  // @@protoc_insertion_point(field_set_allocated:Diagnosis.TemporaryExposureKeyExport.region)
}

// optional int32 batch_num = 4;
inline bool TemporaryExposureKeyExport::_internal_has_batch_num() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TemporaryExposureKeyExport::has_batch_num() const {
  return _internal_has_batch_num();
}
inline void TemporaryExposureKeyExport::clear_batch_num() {
  batch_num_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TemporaryExposureKeyExport::_internal_batch_num() const {
  return batch_num_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TemporaryExposureKeyExport::batch_num() const {
  // @@protoc_insertion_point(field_get:Diagnosis.TemporaryExposureKeyExport.batch_num)
  return _internal_batch_num();
}
inline void TemporaryExposureKeyExport::_internal_set_batch_num(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  batch_num_ = value;
}
inline void TemporaryExposureKeyExport::set_batch_num(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_batch_num(value);
  // @@protoc_insertion_point(field_set:Diagnosis.TemporaryExposureKeyExport.batch_num)
}

// optional int32 batch_size = 5;
inline bool TemporaryExposureKeyExport::_internal_has_batch_size() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool TemporaryExposureKeyExport::has_batch_size() const {
  return _internal_has_batch_size();
}
inline void TemporaryExposureKeyExport::clear_batch_size() {
  batch_size_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TemporaryExposureKeyExport::_internal_batch_size() const {
  return batch_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TemporaryExposureKeyExport::batch_size() const {
  // @@protoc_insertion_point(field_get:Diagnosis.TemporaryExposureKeyExport.batch_size)
  return _internal_batch_size();
}
inline void TemporaryExposureKeyExport::_internal_set_batch_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000010u;
  batch_size_ = value;
}
inline void TemporaryExposureKeyExport::set_batch_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_batch_size(value);
  // @@protoc_insertion_point(field_set:Diagnosis.TemporaryExposureKeyExport.batch_size)
}

// repeated .Diagnosis.SignatureInfo signature_infos = 6;
inline int TemporaryExposureKeyExport::_internal_signature_infos_size() const {
  return signature_infos_.size();
}
inline int TemporaryExposureKeyExport::signature_infos_size() const {
  return _internal_signature_infos_size();
}
inline void TemporaryExposureKeyExport::clear_signature_infos() {
  signature_infos_.Clear();
}
inline ::Diagnosis::SignatureInfo* TemporaryExposureKeyExport::mutable_signature_infos(int index) {
  // @@protoc_insertion_point(field_mutable:Diagnosis.TemporaryExposureKeyExport.signature_infos)
  return signature_infos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Diagnosis::SignatureInfo >*
TemporaryExposureKeyExport::mutable_signature_infos() {
  // @@protoc_insertion_point(field_mutable_list:Diagnosis.TemporaryExposureKeyExport.signature_infos)
  return &signature_infos_;
}
inline const ::Diagnosis::SignatureInfo& TemporaryExposureKeyExport::_internal_signature_infos(int index) const {
  return signature_infos_.Get(index);
}
inline const ::Diagnosis::SignatureInfo& TemporaryExposureKeyExport::signature_infos(int index) const {
  // @@protoc_insertion_point(field_get:Diagnosis.TemporaryExposureKeyExport.signature_infos)
  return _internal_signature_infos(index);
}
inline ::Diagnosis::SignatureInfo* TemporaryExposureKeyExport::_internal_add_signature_infos() {
  return signature_infos_.Add();
}
inline ::Diagnosis::SignatureInfo* TemporaryExposureKeyExport::add_signature_infos() {
  // @@protoc_insertion_point(field_add:Diagnosis.TemporaryExposureKeyExport.signature_infos)
  return _internal_add_signature_infos();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Diagnosis::SignatureInfo >&
TemporaryExposureKeyExport::signature_infos() const {
  // @@protoc_insertion_point(field_list:Diagnosis.TemporaryExposureKeyExport.signature_infos)
  return signature_infos_;
}

// repeated .Diagnosis.TemporaryExposureKey keys = 7;
inline int TemporaryExposureKeyExport::_internal_keys_size() const {
  return keys_.size();
}
inline int TemporaryExposureKeyExport::keys_size() const {
  return _internal_keys_size();
}
inline void TemporaryExposureKeyExport::clear_keys() {
  keys_.Clear();
}
inline ::Diagnosis::TemporaryExposureKey* TemporaryExposureKeyExport::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:Diagnosis.TemporaryExposureKeyExport.keys)
  return keys_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Diagnosis::TemporaryExposureKey >*
TemporaryExposureKeyExport::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:Diagnosis.TemporaryExposureKeyExport.keys)
  return &keys_;
}
inline const ::Diagnosis::TemporaryExposureKey& TemporaryExposureKeyExport::_internal_keys(int index) const {
  return keys_.Get(index);
}
inline const ::Diagnosis::TemporaryExposureKey& TemporaryExposureKeyExport::keys(int index) const {
  // @@protoc_insertion_point(field_get:Diagnosis.TemporaryExposureKeyExport.keys)
  return _internal_keys(index);
}
inline ::Diagnosis::TemporaryExposureKey* TemporaryExposureKeyExport::_internal_add_keys() {
  return keys_.Add();
}
inline ::Diagnosis::TemporaryExposureKey* TemporaryExposureKeyExport::add_keys() {
  // @@protoc_insertion_point(field_add:Diagnosis.TemporaryExposureKeyExport.keys)
  return _internal_add_keys();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Diagnosis::TemporaryExposureKey >&
TemporaryExposureKeyExport::keys() const {
  // @@protoc_insertion_point(field_list:Diagnosis.TemporaryExposureKeyExport.keys)
  return keys_;
}

// -------------------------------------------------------------------

// SignatureInfo

// optional string app_bundle_id = 1;
inline bool SignatureInfo::_internal_has_app_bundle_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SignatureInfo::has_app_bundle_id() const {
  return _internal_has_app_bundle_id();
}
inline void SignatureInfo::clear_app_bundle_id() {
  app_bundle_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SignatureInfo::app_bundle_id() const {
  // @@protoc_insertion_point(field_get:Diagnosis.SignatureInfo.app_bundle_id)
  return _internal_app_bundle_id();
}
inline void SignatureInfo::set_app_bundle_id(const std::string& value) {
  _internal_set_app_bundle_id(value);
  // @@protoc_insertion_point(field_set:Diagnosis.SignatureInfo.app_bundle_id)
}
inline std::string* SignatureInfo::mutable_app_bundle_id() {
  // @@protoc_insertion_point(field_mutable:Diagnosis.SignatureInfo.app_bundle_id)
  return _internal_mutable_app_bundle_id();
}
inline const std::string& SignatureInfo::_internal_app_bundle_id() const {
  return app_bundle_id_.GetNoArena();
}
inline void SignatureInfo::_internal_set_app_bundle_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  app_bundle_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void SignatureInfo::set_app_bundle_id(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  app_bundle_id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Diagnosis.SignatureInfo.app_bundle_id)
}
inline void SignatureInfo::set_app_bundle_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  app_bundle_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Diagnosis.SignatureInfo.app_bundle_id)
}
inline void SignatureInfo::set_app_bundle_id(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  app_bundle_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Diagnosis.SignatureInfo.app_bundle_id)
}
inline std::string* SignatureInfo::_internal_mutable_app_bundle_id() {
  _has_bits_[0] |= 0x00000001u;
  return app_bundle_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SignatureInfo::release_app_bundle_id() {
  // @@protoc_insertion_point(field_release:Diagnosis.SignatureInfo.app_bundle_id)
  if (!has_app_bundle_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return app_bundle_id_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SignatureInfo::set_allocated_app_bundle_id(std::string* app_bundle_id) {
  if (app_bundle_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  app_bundle_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), app_bundle_id);
  // @@protoc_insertion_point(field_set_allocated:Diagnosis.SignatureInfo.app_bundle_id)
}

// optional string android_package = 2;
inline bool SignatureInfo::_internal_has_android_package() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SignatureInfo::has_android_package() const {
  return _internal_has_android_package();
}
inline void SignatureInfo::clear_android_package() {
  android_package_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SignatureInfo::android_package() const {
  // @@protoc_insertion_point(field_get:Diagnosis.SignatureInfo.android_package)
  return _internal_android_package();
}
inline void SignatureInfo::set_android_package(const std::string& value) {
  _internal_set_android_package(value);
  // @@protoc_insertion_point(field_set:Diagnosis.SignatureInfo.android_package)
}
inline std::string* SignatureInfo::mutable_android_package() {
  // @@protoc_insertion_point(field_mutable:Diagnosis.SignatureInfo.android_package)
  return _internal_mutable_android_package();
}
inline const std::string& SignatureInfo::_internal_android_package() const {
  return android_package_.GetNoArena();
}
inline void SignatureInfo::_internal_set_android_package(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  android_package_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void SignatureInfo::set_android_package(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  android_package_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Diagnosis.SignatureInfo.android_package)
}
inline void SignatureInfo::set_android_package(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  android_package_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Diagnosis.SignatureInfo.android_package)
}
inline void SignatureInfo::set_android_package(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  android_package_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Diagnosis.SignatureInfo.android_package)
}
inline std::string* SignatureInfo::_internal_mutable_android_package() {
  _has_bits_[0] |= 0x00000002u;
  return android_package_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SignatureInfo::release_android_package() {
  // @@protoc_insertion_point(field_release:Diagnosis.SignatureInfo.android_package)
  if (!has_android_package()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return android_package_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SignatureInfo::set_allocated_android_package(std::string* android_package) {
  if (android_package != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  android_package_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), android_package);
  // @@protoc_insertion_point(field_set_allocated:Diagnosis.SignatureInfo.android_package)
}

// optional string verification_key_version = 3;
inline bool SignatureInfo::_internal_has_verification_key_version() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SignatureInfo::has_verification_key_version() const {
  return _internal_has_verification_key_version();
}
inline void SignatureInfo::clear_verification_key_version() {
  verification_key_version_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& SignatureInfo::verification_key_version() const {
  // @@protoc_insertion_point(field_get:Diagnosis.SignatureInfo.verification_key_version)
  return _internal_verification_key_version();
}
inline void SignatureInfo::set_verification_key_version(const std::string& value) {
  _internal_set_verification_key_version(value);
  // @@protoc_insertion_point(field_set:Diagnosis.SignatureInfo.verification_key_version)
}
inline std::string* SignatureInfo::mutable_verification_key_version() {
  // @@protoc_insertion_point(field_mutable:Diagnosis.SignatureInfo.verification_key_version)
  return _internal_mutable_verification_key_version();
}
inline const std::string& SignatureInfo::_internal_verification_key_version() const {
  return verification_key_version_.GetNoArena();
}
inline void SignatureInfo::_internal_set_verification_key_version(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  verification_key_version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void SignatureInfo::set_verification_key_version(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  verification_key_version_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Diagnosis.SignatureInfo.verification_key_version)
}
inline void SignatureInfo::set_verification_key_version(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  verification_key_version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Diagnosis.SignatureInfo.verification_key_version)
}
inline void SignatureInfo::set_verification_key_version(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  verification_key_version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Diagnosis.SignatureInfo.verification_key_version)
}
inline std::string* SignatureInfo::_internal_mutable_verification_key_version() {
  _has_bits_[0] |= 0x00000004u;
  return verification_key_version_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SignatureInfo::release_verification_key_version() {
  // @@protoc_insertion_point(field_release:Diagnosis.SignatureInfo.verification_key_version)
  if (!has_verification_key_version()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return verification_key_version_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SignatureInfo::set_allocated_verification_key_version(std::string* verification_key_version) {
  if (verification_key_version != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  verification_key_version_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), verification_key_version);
  // @@protoc_insertion_point(field_set_allocated:Diagnosis.SignatureInfo.verification_key_version)
}

// optional string verification_key_id = 4;
inline bool SignatureInfo::_internal_has_verification_key_id() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SignatureInfo::has_verification_key_id() const {
  return _internal_has_verification_key_id();
}
inline void SignatureInfo::clear_verification_key_id() {
  verification_key_id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& SignatureInfo::verification_key_id() const {
  // @@protoc_insertion_point(field_get:Diagnosis.SignatureInfo.verification_key_id)
  return _internal_verification_key_id();
}
inline void SignatureInfo::set_verification_key_id(const std::string& value) {
  _internal_set_verification_key_id(value);
  // @@protoc_insertion_point(field_set:Diagnosis.SignatureInfo.verification_key_id)
}
inline std::string* SignatureInfo::mutable_verification_key_id() {
  // @@protoc_insertion_point(field_mutable:Diagnosis.SignatureInfo.verification_key_id)
  return _internal_mutable_verification_key_id();
}
inline const std::string& SignatureInfo::_internal_verification_key_id() const {
  return verification_key_id_.GetNoArena();
}
inline void SignatureInfo::_internal_set_verification_key_id(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  verification_key_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void SignatureInfo::set_verification_key_id(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  verification_key_id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Diagnosis.SignatureInfo.verification_key_id)
}
inline void SignatureInfo::set_verification_key_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  verification_key_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Diagnosis.SignatureInfo.verification_key_id)
}
inline void SignatureInfo::set_verification_key_id(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000008u;
  verification_key_id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Diagnosis.SignatureInfo.verification_key_id)
}
inline std::string* SignatureInfo::_internal_mutable_verification_key_id() {
  _has_bits_[0] |= 0x00000008u;
  return verification_key_id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SignatureInfo::release_verification_key_id() {
  // @@protoc_insertion_point(field_release:Diagnosis.SignatureInfo.verification_key_id)
  if (!has_verification_key_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return verification_key_id_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SignatureInfo::set_allocated_verification_key_id(std::string* verification_key_id) {
  if (verification_key_id != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  verification_key_id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), verification_key_id);
  // @@protoc_insertion_point(field_set_allocated:Diagnosis.SignatureInfo.verification_key_id)
}

// optional string signature_algorithm = 5;
inline bool SignatureInfo::_internal_has_signature_algorithm() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool SignatureInfo::has_signature_algorithm() const {
  return _internal_has_signature_algorithm();
}
inline void SignatureInfo::clear_signature_algorithm() {
  signature_algorithm_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& SignatureInfo::signature_algorithm() const {
  // @@protoc_insertion_point(field_get:Diagnosis.SignatureInfo.signature_algorithm)
  return _internal_signature_algorithm();
}
inline void SignatureInfo::set_signature_algorithm(const std::string& value) {
  _internal_set_signature_algorithm(value);
  // @@protoc_insertion_point(field_set:Diagnosis.SignatureInfo.signature_algorithm)
}
inline std::string* SignatureInfo::mutable_signature_algorithm() {
  // @@protoc_insertion_point(field_mutable:Diagnosis.SignatureInfo.signature_algorithm)
  return _internal_mutable_signature_algorithm();
}
inline const std::string& SignatureInfo::_internal_signature_algorithm() const {
  return signature_algorithm_.GetNoArena();
}
inline void SignatureInfo::_internal_set_signature_algorithm(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  signature_algorithm_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void SignatureInfo::set_signature_algorithm(std::string&& value) {
  _has_bits_[0] |= 0x00000010u;
  signature_algorithm_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Diagnosis.SignatureInfo.signature_algorithm)
}
inline void SignatureInfo::set_signature_algorithm(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000010u;
  signature_algorithm_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Diagnosis.SignatureInfo.signature_algorithm)
}
inline void SignatureInfo::set_signature_algorithm(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000010u;
  signature_algorithm_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Diagnosis.SignatureInfo.signature_algorithm)
}
inline std::string* SignatureInfo::_internal_mutable_signature_algorithm() {
  _has_bits_[0] |= 0x00000010u;
  return signature_algorithm_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SignatureInfo::release_signature_algorithm() {
  // @@protoc_insertion_point(field_release:Diagnosis.SignatureInfo.signature_algorithm)
  if (!has_signature_algorithm()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return signature_algorithm_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SignatureInfo::set_allocated_signature_algorithm(std::string* signature_algorithm) {
  if (signature_algorithm != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  signature_algorithm_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), signature_algorithm);
  // @@protoc_insertion_point(field_set_allocated:Diagnosis.SignatureInfo.signature_algorithm)
}

// -------------------------------------------------------------------

// TemporaryExposureKey

// optional bytes key_data = 1;
inline bool TemporaryExposureKey::_internal_has_key_data() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TemporaryExposureKey::has_key_data() const {
  return _internal_has_key_data();
}
inline void TemporaryExposureKey::clear_key_data() {
  key_data_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TemporaryExposureKey::key_data() const {
  // @@protoc_insertion_point(field_get:Diagnosis.TemporaryExposureKey.key_data)
  return _internal_key_data();
}
inline void TemporaryExposureKey::set_key_data(const std::string& value) {
  _internal_set_key_data(value);
  // @@protoc_insertion_point(field_set:Diagnosis.TemporaryExposureKey.key_data)
}
inline std::string* TemporaryExposureKey::mutable_key_data() {
  // @@protoc_insertion_point(field_mutable:Diagnosis.TemporaryExposureKey.key_data)
  return _internal_mutable_key_data();
}
inline const std::string& TemporaryExposureKey::_internal_key_data() const {
  return key_data_.GetNoArena();
}
inline void TemporaryExposureKey::_internal_set_key_data(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  key_data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void TemporaryExposureKey::set_key_data(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  key_data_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Diagnosis.TemporaryExposureKey.key_data)
}
inline void TemporaryExposureKey::set_key_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  key_data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Diagnosis.TemporaryExposureKey.key_data)
}
inline void TemporaryExposureKey::set_key_data(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  key_data_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Diagnosis.TemporaryExposureKey.key_data)
}
inline std::string* TemporaryExposureKey::_internal_mutable_key_data() {
  _has_bits_[0] |= 0x00000001u;
  return key_data_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* TemporaryExposureKey::release_key_data() {
  // @@protoc_insertion_point(field_release:Diagnosis.TemporaryExposureKey.key_data)
  if (!has_key_data()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return key_data_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void TemporaryExposureKey::set_allocated_key_data(std::string* key_data) {
  if (key_data != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  key_data_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key_data);
  // @@protoc_insertion_point(field_set_allocated:Diagnosis.TemporaryExposureKey.key_data)
}

// optional int32 transmission_risk_level = 2;
inline bool TemporaryExposureKey::_internal_has_transmission_risk_level() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TemporaryExposureKey::has_transmission_risk_level() const {
  return _internal_has_transmission_risk_level();
}
inline void TemporaryExposureKey::clear_transmission_risk_level() {
  transmission_risk_level_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TemporaryExposureKey::_internal_transmission_risk_level() const {
  return transmission_risk_level_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TemporaryExposureKey::transmission_risk_level() const {
  // @@protoc_insertion_point(field_get:Diagnosis.TemporaryExposureKey.transmission_risk_level)
  return _internal_transmission_risk_level();
}
inline void TemporaryExposureKey::_internal_set_transmission_risk_level(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  transmission_risk_level_ = value;
}
inline void TemporaryExposureKey::set_transmission_risk_level(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_transmission_risk_level(value);
  // @@protoc_insertion_point(field_set:Diagnosis.TemporaryExposureKey.transmission_risk_level)
}

// optional int32 rolling_start_interval_number = 3;
inline bool TemporaryExposureKey::_internal_has_rolling_start_interval_number() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TemporaryExposureKey::has_rolling_start_interval_number() const {
  return _internal_has_rolling_start_interval_number();
}
inline void TemporaryExposureKey::clear_rolling_start_interval_number() {
  rolling_start_interval_number_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TemporaryExposureKey::_internal_rolling_start_interval_number() const {
  return rolling_start_interval_number_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TemporaryExposureKey::rolling_start_interval_number() const {
  // @@protoc_insertion_point(field_get:Diagnosis.TemporaryExposureKey.rolling_start_interval_number)
  return _internal_rolling_start_interval_number();
}
inline void TemporaryExposureKey::_internal_set_rolling_start_interval_number(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  rolling_start_interval_number_ = value;
}
inline void TemporaryExposureKey::set_rolling_start_interval_number(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_rolling_start_interval_number(value);
  // @@protoc_insertion_point(field_set:Diagnosis.TemporaryExposureKey.rolling_start_interval_number)
}

// optional int32 rolling_period = 4 [default = 144];
inline bool TemporaryExposureKey::_internal_has_rolling_period() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TemporaryExposureKey::has_rolling_period() const {
  return _internal_has_rolling_period();
}
inline void TemporaryExposureKey::clear_rolling_period() {
  rolling_period_ = 144;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TemporaryExposureKey::_internal_rolling_period() const {
  return rolling_period_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TemporaryExposureKey::rolling_period() const {
  // @@protoc_insertion_point(field_get:Diagnosis.TemporaryExposureKey.rolling_period)
  return _internal_rolling_period();
}
inline void TemporaryExposureKey::_internal_set_rolling_period(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  rolling_period_ = value;
}
inline void TemporaryExposureKey::set_rolling_period(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_rolling_period(value);
  // @@protoc_insertion_point(field_set:Diagnosis.TemporaryExposureKey.rolling_period)
}

// -------------------------------------------------------------------

// TEKSignatureList

// repeated .Diagnosis.TEKSignature signatures = 1;
inline int TEKSignatureList::_internal_signatures_size() const {
  return signatures_.size();
}
inline int TEKSignatureList::signatures_size() const {
  return _internal_signatures_size();
}
inline void TEKSignatureList::clear_signatures() {
  signatures_.Clear();
}
inline ::Diagnosis::TEKSignature* TEKSignatureList::mutable_signatures(int index) {
  // @@protoc_insertion_point(field_mutable:Diagnosis.TEKSignatureList.signatures)
  return signatures_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Diagnosis::TEKSignature >*
TEKSignatureList::mutable_signatures() {
  // @@protoc_insertion_point(field_mutable_list:Diagnosis.TEKSignatureList.signatures)
  return &signatures_;
}
inline const ::Diagnosis::TEKSignature& TEKSignatureList::_internal_signatures(int index) const {
  return signatures_.Get(index);
}
inline const ::Diagnosis::TEKSignature& TEKSignatureList::signatures(int index) const {
  // @@protoc_insertion_point(field_get:Diagnosis.TEKSignatureList.signatures)
  return _internal_signatures(index);
}
inline ::Diagnosis::TEKSignature* TEKSignatureList::_internal_add_signatures() {
  return signatures_.Add();
}
inline ::Diagnosis::TEKSignature* TEKSignatureList::add_signatures() {
  // @@protoc_insertion_point(field_add:Diagnosis.TEKSignatureList.signatures)
  return _internal_add_signatures();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Diagnosis::TEKSignature >&
TEKSignatureList::signatures() const {
  // @@protoc_insertion_point(field_list:Diagnosis.TEKSignatureList.signatures)
  return signatures_;
}

// -------------------------------------------------------------------

// TEKSignature

// optional .Diagnosis.SignatureInfo signature_info = 1;
inline bool TEKSignature::_internal_has_signature_info() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || signature_info_ != nullptr);
  return value;
}
inline bool TEKSignature::has_signature_info() const {
  return _internal_has_signature_info();
}
inline void TEKSignature::clear_signature_info() {
  if (signature_info_ != nullptr) signature_info_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::Diagnosis::SignatureInfo& TEKSignature::_internal_signature_info() const {
  const ::Diagnosis::SignatureInfo* p = signature_info_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Diagnosis::SignatureInfo*>(
      &::Diagnosis::_SignatureInfo_default_instance_);
}
inline const ::Diagnosis::SignatureInfo& TEKSignature::signature_info() const {
  // @@protoc_insertion_point(field_get:Diagnosis.TEKSignature.signature_info)
  return _internal_signature_info();
}
inline ::Diagnosis::SignatureInfo* TEKSignature::release_signature_info() {
  // @@protoc_insertion_point(field_release:Diagnosis.TEKSignature.signature_info)
  _has_bits_[0] &= ~0x00000002u;
  ::Diagnosis::SignatureInfo* temp = signature_info_;
  signature_info_ = nullptr;
  return temp;
}
inline ::Diagnosis::SignatureInfo* TEKSignature::_internal_mutable_signature_info() {
  _has_bits_[0] |= 0x00000002u;
  if (signature_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::Diagnosis::SignatureInfo>(GetArenaNoVirtual());
    signature_info_ = p;
  }
  return signature_info_;
}
inline ::Diagnosis::SignatureInfo* TEKSignature::mutable_signature_info() {
  // @@protoc_insertion_point(field_mutable:Diagnosis.TEKSignature.signature_info)
  return _internal_mutable_signature_info();
}
inline void TEKSignature::set_allocated_signature_info(::Diagnosis::SignatureInfo* signature_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete signature_info_;
  }
  if (signature_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      signature_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, signature_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  signature_info_ = signature_info;
  // @@protoc_insertion_point(field_set_allocated:Diagnosis.TEKSignature.signature_info)
}

// optional int32 batch_num = 2;
inline bool TEKSignature::_internal_has_batch_num() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TEKSignature::has_batch_num() const {
  return _internal_has_batch_num();
}
inline void TEKSignature::clear_batch_num() {
  batch_num_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TEKSignature::_internal_batch_num() const {
  return batch_num_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TEKSignature::batch_num() const {
  // @@protoc_insertion_point(field_get:Diagnosis.TEKSignature.batch_num)
  return _internal_batch_num();
}
inline void TEKSignature::_internal_set_batch_num(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  batch_num_ = value;
}
inline void TEKSignature::set_batch_num(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_batch_num(value);
  // @@protoc_insertion_point(field_set:Diagnosis.TEKSignature.batch_num)
}

// optional int32 batch_size = 3;
inline bool TEKSignature::_internal_has_batch_size() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TEKSignature::has_batch_size() const {
  return _internal_has_batch_size();
}
inline void TEKSignature::clear_batch_size() {
  batch_size_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TEKSignature::_internal_batch_size() const {
  return batch_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TEKSignature::batch_size() const {
  // @@protoc_insertion_point(field_get:Diagnosis.TEKSignature.batch_size)
  return _internal_batch_size();
}
inline void TEKSignature::_internal_set_batch_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  batch_size_ = value;
}
inline void TEKSignature::set_batch_size(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_batch_size(value);
  // @@protoc_insertion_point(field_set:Diagnosis.TEKSignature.batch_size)
}

// optional bytes signature = 4;
inline bool TEKSignature::_internal_has_signature() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TEKSignature::has_signature() const {
  return _internal_has_signature();
}
inline void TEKSignature::clear_signature() {
  signature_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TEKSignature::signature() const {
  // @@protoc_insertion_point(field_get:Diagnosis.TEKSignature.signature)
  return _internal_signature();
}
inline void TEKSignature::set_signature(const std::string& value) {
  _internal_set_signature(value);
  // @@protoc_insertion_point(field_set:Diagnosis.TEKSignature.signature)
}
inline std::string* TEKSignature::mutable_signature() {
  // @@protoc_insertion_point(field_mutable:Diagnosis.TEKSignature.signature)
  return _internal_mutable_signature();
}
inline const std::string& TEKSignature::_internal_signature() const {
  return signature_.GetNoArena();
}
inline void TEKSignature::_internal_set_signature(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  signature_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void TEKSignature::set_signature(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  signature_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Diagnosis.TEKSignature.signature)
}
inline void TEKSignature::set_signature(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  signature_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Diagnosis.TEKSignature.signature)
}
inline void TEKSignature::set_signature(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  signature_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Diagnosis.TEKSignature.signature)
}
inline std::string* TEKSignature::_internal_mutable_signature() {
  _has_bits_[0] |= 0x00000001u;
  return signature_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* TEKSignature::release_signature() {
  // @@protoc_insertion_point(field_release:Diagnosis.TEKSignature.signature)
  if (!has_signature()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return signature_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void TEKSignature::set_allocated_signature(std::string* signature) {
  if (signature != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  signature_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), signature);
  // @@protoc_insertion_point(field_set_allocated:Diagnosis.TEKSignature.signature)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Diagnosis

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_contrac_2eproto
